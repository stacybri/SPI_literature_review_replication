labs(
title=str_wrap(paste(title, 'By Fragile and Conflict-affected Situations (FCS)', sep=" - "),100),
caption = 'Source: World Bank. Statistical Performance Indicators.',
subtitle= 'Based on data for 2022 or the latest year available'
) +
scale_y_discrete(limits = fcs_list) +
expand_limits(x=c(0,100)) +
theme_spi() +
theme(legend.position = 'top',
text=element_text(size=14))
p2_alt2
}
fcs_chart_aggregate <- function(data, indicator, title) {
#FY21 Fragile and conflict-affected situations (http://pubdocs.worldbank.org/en/888211594267968803/FCSList-FY21.pdf)
high_intensity_conflict <- c('Afghanistan', 'Libya', 'Somalia', 'Syrian Arab Republic' )
medium_intensity_conflict <- c('Burkina Faso', 'Cameroon','Central African Republic', 'Chad', 'Congo, Dem. Rep.',
'Iraq','Mali','Mozambique','Myanmar','Niger','Nigeria','South Sudan','Yemen, Rep.')
high_institutional_social_fragility <- c('Burundi','Congo, Rep.','Eritrea','Gambia, The','Guinea-Bissau',
'Haiti','Kosovo','Lao PDR','Lebanon','Liberia','Papua New Guinea',
'Sudan','Venezuela, RB','West Bank and Gaza','Zimbabwe')
small_states <- c('Comoros','Kiribati','Marshall Islands','Micronesia, Fed. Sts.','Solomon Islands','Timor-Leste','Tuvalu')
indicator<-indicator
map_df <- get(data) %>%
filter(date==max(date, na.rm=T)) %>%
filter(!(country %in% c('Greenland'))) %>% #drop a few countries for which we do not collect data.
mutate(fcs=case_when( #create indicators for Fragile and Conflict-affected Situations
country %in% high_intensity_conflict ~ "FCS country",
country %in% medium_intensity_conflict ~ "FCS country",
country %in% high_institutional_social_fragility ~ "FCS country",
country %in% small_states ~ "FCS country",
TRUE ~ "Non-FCS country"
)) %>%
mutate(fcs_detail=case_when( #create indicators for Fragile and Conflict-affected Situations
country %in% high_intensity_conflict ~ "High-Intensity Conflict",
country %in% medium_intensity_conflict ~ "Medium-Intensity Conflict",
country %in% high_institutional_social_fragility ~ "High Institutional & Social Fragility",
country %in% small_states ~ "Small States",
TRUE ~ "Non-FCS country"
)) %>%
group_by( country) %>%
#summarise(across(!! indicator,last)) %>%
rename(data_available=!! indicator) %>%
select(country,fcs,fcs_detail, date, data_available, weights ) %>%
right_join(country_metadata) %>%
mutate(data_available=if_else(is.na(data_available), as.numeric(NA), as.numeric(data_available)))
fcs_list <- c("High-Intensity Conflict", "Medium-Intensity Conflict","High Institutional & Social Fragility","Small States","Non-FCS country")
fcs_list <- c("FCS country","Non-FCS country")
p2_alt2 <- map_df %>%
group_by(fcs) %>%
filter(region!='Aggregates') %>%
mutate(`SPI Score`=wtd.mean(data_available, weights = weights, na.rm=T),
Label = paste(round(`SPI Score`,0))) %>%
ggplot(aes(x=`SPI Score`, y=fcs, fill=fcs)) +
geom_bar(stat="identity",position='dodge') +
geom_text(aes(label=Label)) +
labs(
title=str_wrap(paste(title, 'By Fragile and Conflict-affected Situations (FCS)', sep=" - "),100),
caption = 'Source: World Bank. Statistical Performance Indicators.',
subtitle= 'Based on data for 2022 or the latest year available'
) +
scale_y_discrete(limits = fcs_list) +
expand_limits(x=c(0,100)) +
theme_spi() +
theme(legend.position = 'top',
text=element_text(size=14))
p2_alt2
}
FitFlextableToPage <- function(ft, pgwidth = 6){
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, width = dim(ft_out)$widths*pgwidth /(flextable_dim(ft_out)$widths))
return(ft_out)
}
#add equations to plots
eq_plot_txt <- function(data, inp, var) {
eq <- lm_robust(inp ~ var, data=data, se_type='HC2')
coef <- round(coef(eq),1)
std_err <- round(sqrt(diag(vcov(eq))),1)
r_2<- round(summary(eq)$r.squared,2)
sprintf(" y = %.1f + %.1f x, R<sup>2</sup> = %.2f <br> (%.1f) <span style='color:white'> %s</span> (%.1f) ", coef[1], coef[2], r_2[1], std_err[1],"s", std_err[2])
}
#| label: dataread
#import data specificially about the SPI
spi_index_df <- read_csv(paste(raw_dir, 'SPI_index.csv', sep="/"))
spi_df_final <- read_csv( file = paste(raw_dir, 'SPI_data.csv', sep="/"))
#metadata
metadata <- data.frame(
series = c('SPI.INDEX', 'SPI.INDEX.PIL1', 'SPI.INDEX.PIL2', 'SPI.INDEX.PIL3', 'SPI.INDEX.PIL4', 'SPI.INDEX.PIL5'),
indicator_name = c('SPI Overall Score', 'Pillar 1: Data Use', 'Pillar 2: Data Services', 'Pillar 3: Data Products', 'Pillar 4: Data Sources', 'Pillar 5: Data Infrastructure')
)
SPI_end_date <- spi_index_df %>%
filter(date==end_date) %>%
filter(!is.na(SPI.INDEX) & !is.na(weights)) %>%
mutate(ISO_A3_EH=iso3c)
SPI <- spi_index_df
## Read in data produced in ./02_programs/misc/spi_lit_review_data_preparation.Rmd
fig1_df <- read_csv(paste0(output_dir, "/Figure_1_data.csv"))
#read in data comparing SPI to other indices and SDGs
comparison_df <- read_csv(paste0(output_dir, "/SPI_Index_SDG_comparisons_data.csv"))
#read in regression data with covariates
predictors_df <- read_csv(paste0(output_dir, "/SPI_regression_predictors.csv"))
#| label: m2_spi_correlations
#| fig-width: 9
#| fig-height: 6
corr_df <- spi_index_df %>%
ungroup() %>%
select(starts_with('SPI.INDEX'))
#calculate correlations between teacher practices
df_corr_plot <-    round(cor(corr_df, use="complete.obs"), 2)
colnames(df_corr_plot) <- c('Data Use','Data Services','Data Products','Data Sources','Data Infrastructure','SPI Overall')
rownames(df_corr_plot) <- c('Data Use','Data Services','Data Products','Data Sources','Data Infrastructure','SPI Overall')
#plot the correlation in a nicely formatted table
pcorr<- ggcorrplot::ggcorrplot(df_corr_plot,
outline.color = "white",
ggtheme = theme_spi(),
colors = c("#F8696B", "#FFEB84", "#63BE7B"),
legend.title = "Correlation",
title = "Correlation Between SPI pillars",
lab=T) +
scale_x_discrete(labels = function(x) str_wrap(x, width = 12)) +
scale_y_discrete(labels = function(x) str_wrap(x, width = 16)) +
theme_spi() +
theme(
text = element_text(size = 12),
axis.text.x = element_text(angle=45,vjust=.5)
) +
labs( )
pcorr
#| label: decompstacked
decomp_stacked_df <- SPI %>%
filter(date==2022) %>%
select(country, income, iso3c, date, starts_with('SPI.INDEX')) %>%
filter(!is.na(SPI.INDEX))
#summarise into decile bins
decomp_stacked_df <- decomp_stacked_df %>%
group_by(income) %>%
summarise(across(starts_with('SPI.INDEX'), mean, na.rm=T)) %>%
pivot_longer(
cols=c('SPI.INDEX.PIL1', 'SPI.INDEX.PIL2', 'SPI.INDEX.PIL3', 'SPI.INDEX.PIL4', 'SPI.INDEX.PIL5'),
values_to='level',
names_to='Pillar'
) %>%
mutate(Pillar=case_when(
Pillar=="SPI.INDEX.PIL1" ~ "Pillar 1: Data Use",
Pillar=="SPI.INDEX.PIL2" ~ "Pillar 2: Data Services",
Pillar=="SPI.INDEX.PIL3" ~ "Pillar 3: Data Products",
Pillar=="SPI.INDEX.PIL4" ~ "Pillar 4: Data Sources",
Pillar=="SPI.INDEX.PIL5" ~ "Pillar 5: Data Infrastructure"
)) %>%
group_by(income) %>%
mutate(level=level/5,
total=sum(level)) #divide by 5 so that Pillar scores sum to overall score.  This puts equal weight on each Pillar in the sum
#| label: decompstackedpltabs
#| fig-height: 8
#| fig-width: 12
name <- 'SPI Overall Score'
income <- c("Low income", "Lower middle income","Upper middle income","High income")
#absolute graph
ggplot(decomp_stacked_df, aes(x=income, y=level, fill=Pillar, label=paste0(round(level,1)))) +
geom_bar(stat = "identity", position='stack') +
geom_text(size = 4, position = position_stack(vjust = 0.5)) +
geom_text(aes(y=total,label=paste0('Total = ' ,round(total,1))), size=4, nudge_y=7 ) +
scale_x_discrete() +
theme_spi() +
labs(
#title='Contribution of each Pillar to SPI overall score',
subtitle='Each pillar receives equal 1/5th weight in overall score',
caption=paste0(name,' scale = 0 - 100 points.')
) +
scale_x_discrete(limits = income) +
coord_flip() +
expand_limits(y=c(0,100)) +
theme(
axis.title.y = element_text(angle=0, vjust = 0.5),
text = element_text(size = 12),
title= element_text(size = 14),
legend.position = 'bottom'
) +
guides(fill=guide_legend(nrow=2,byrow=TRUE))
#| label: decompstackedpltrel
#| fig-height: 8
#| fig-width: 12
#relative graph
ggplot(decomp_stacked_df, aes(x=income, y=100*level/total, fill=Pillar, label=paste0(round(100*level/total,1),"%"))) +
geom_bar(stat = "identity", position='stack') +
geom_text(size = 4, position = position_stack(vjust = 0.5)) +
#geom_text(aes(y=total,label=paste0('Total = ' ,round(total,1))), size=4, nudge_y=7 ) +
scale_x_discrete() +
theme_spi() +
ylab('percentage') +
labs(
#title='Relative Contribution of each dimension to SPI overall score',
subtitle='Each pillar receives equal 1/5th weight in overall score',
caption=paste0(name,' scale = 0 - 100 points.')
) +
scale_x_discrete(limits = income) +
coord_flip() +
expand_limits(y=c(0,100)) +
theme(
axis.title.y = element_text(angle=0, vjust = 0.5),
text = element_text(size = 12),
title= element_text(size = 14),
legend.position = 'bottom'
) +
guides(fill=guide_legend(nrow=2,byrow=TRUE))
#| label: incomesurveys
#| fig-width: 9
#| fig-height: 6
#read in data from World Bank's PIP
pip_df <- read_csv(paste0(output_dir, "/Figure_1_data.csv")) %>%
mutate(log_welfare = log(mean_welfare)) # create logged welfare for figure
#plot number of surveys against mean welfare in 2022.
ggplot(pip_df, aes(x=mean_welfare, y=number_surveys)) +
geom_point(color='blue') +
geom_smooth(method='lm', se=FALSE, color='darkred') +
theme_spi() +
#scale_x_continuous(trans = scales::log2_trans()) +
ylab('Number of Poverty Surveys') +
xlab('$ Mean Welfare (logged scale)') +
geom_richtext(
aes(x = 2, y = 45,label = eq_plot_txt(pip_df, number_surveys, log_welfare), hjust=0.2)
) +
scale_x_log10(
label=scales::comma
) +
labs(
caption = str_wrap('Note: Estimated coefficients are shown from an OLS regression of the number of surveys on log of mean consumption (income); robust standard errors are in parentheses.',100)
) +
#annotate("label", x = 20, y = 5, label = eq_plot_txt(pov_df_2022), hjust = 0) +
theme(legend.position = 'bottom'
)
#| label: frameworkdf
table_2_df <- read_excel(path = paste0(raw_dir, "/SPI_Index_compare.xlsx"))
dat <- table_2_df %>%
select(Index, `Assessment Type`, `Country Coverage`, `Time Coverage`, `Index Methodology`, `Number of Indicators`, ends_with("Percentage")) %>%
pivot_longer(cols=ends_with("Percentage"),
names_to = 'Pillar',
values_to = 'Pillar Coverage') %>%
mutate(Pillar=str_remove_all(Pillar, " Percentage"),
Pillar=str_remove_all(Pillar, "Data "),
short_name=case_when(
Index=="SPI" ~ "SPI",
Index=="SCI" ~ "SCI",
Index=="ODIN" ~ "ODIN",
Index=="Open Data Barometer" ~ "ODB",
Index=="Global Data Barometer" ~ "GDB",
Index=="Ibrahim Index of African Governance Statistical Capacity Measure" ~ "IIAG",
Index=="EU Snapshot tool"    ~ "Snapshot",
Index=="UN NQAF self checklist"  ~ "NQAF" ,
Index=="Paris21 NSDS self assessment" ~ "NSDS"
))
radarfun <- function(variables) {
temp <- dat %>%
filter(Index== variables) %>%
select(Pillar, `Pillar Coverage`) %>%
mutate(`Pillar`=str_remove(`Pillar`, " Indicator")) %>%
pivot_wider(
names_from=Pillar,
values_from=`Pillar Coverage`
)
}
min <- data.frame(
Use          = c(0) ,
Services     = c(0) ,
Products     = c(0) ,
Sources      = c(0) ,
Infrastructure = c(0)
)
max <- data.frame(
Use          = c(1) ,
Services     = c(1) ,
Products     = c(1) ,
Sources      = c(1) ,
Infrastructure = c(1)
)
ideal <-    data.frame(
Use          = c(0.2) ,
Services     = c(0.2) ,
Products     = c(0.2) ,
Sources      = c(0.2) ,
Infrastructure = c(0.2)
)
color <- c("#33a8c7",
"#52e3e1",
"#a0e426",
"#fdf148",
"#ffab00",
"#f77976",
"#f050ae",
"#bdb2ff",
"#d883ff",
"#9336fd")
names(color) <- unique(dat$Index)
radarplt <- function(variables, color = "#00AFBB",
vlabels = colnames(data), vlcex = 0.7,
caxislabels = NULL,  ...) {
if (variables=="Ibrahim Index of African Governance Statistical Capacity Measure") {
title="Ibrahim Index"
} else {
title=variables
}
max %>%
bind_rows(min) %>%
bind_rows(ideal) %>%
bind_rows(radarfun(variables)) %>%
radarchart(axistype = 1,
# Customize the polygon
pcol = c('#83c5be',color), pfcol = c(scales::alpha('#83c5be', 0.5),scales::alpha(color, 0.7)), plwd = 2, plty = 1,
# Customize the grid
cglcol = "grey", cglty = 1, cglwd = 0.8,cex.main=2,
# Customize the axis
axislabcol = "grey",
# Variable labels
vlcex = vlcex, vlabels = vlabels,
caxislabels = caxislabels, title = title, ...)
}
#| label: fig2
#| fig-width: 15
#| fig-height: 15
#|
par(mar = c(1, 1, 1, 1)) #decrease default margin
layout(matrix(1:9, ncol=3)) #draw 4 plots to device
#loop over rows to draw them, add 1 as max and 0 as min for each var
lapply(unique(dat$Index), function(i) {
radarplt(i, color=color[i],
vlcex=1.1,
calcex=1.1)
})
#| label: volatilitydf1
odin_df <- read_csv(paste0(output_dir, "/ODIN_formatted_data.csv"))
#combine spi with odin
volatility_df <- SPI %>%
left_join(odin_df) %>%
select(country, iso3c, date,income, region, SPI.INDEX, ODIN_score)
#| label: country progress
# this code will calculate trends based on the five years between 2016 and 2020 for the SPI and ODIN
country_progress_data <- volatility_df %>%
filter(between(date, 2016,2022)) %>%
group_by(iso3c) %>%
filter(all(!is.na(SPI.INDEX))) %>%
filter(all(!is.na(ODIN_score)))
#get trend data
trend_data <- country_progress_data %>%
filter(between(date, 2016, 2020))
#create trend model
SPI_trend_models <- trend_data %>%
group_by(iso3c) %>%
do(model = lm(SPI.INDEX ~ date, data = .),
) %>%
ungroup()
ODIN_trend_models <- trend_data %>%
group_by(iso3c) %>%
do(
model = lm(ODIN_score ~ date, data = .)) %>%
ungroup()
# get prediction data for 2021 and 2022
prediction_data <- country_progress_data %>%
filter(between(date, 2021, 2022))
# Predict using the fitted models
SPI_prediction_data <- prediction_data %>%
left_join(SPI_trend_models, by = "iso3c") %>%
group_by(iso3c) %>%
do(modelr::add_predictions(., first(.$model), var="SPI_predicted_values")) %>%
select(-model)
ODIN_prediction_data <- prediction_data %>%
left_join(ODIN_trend_models, by = "iso3c") %>%
group_by(iso3c) %>%
do(modelr::add_predictions(., first(.$model), var="ODIN_predicted_values")) %>%
select(-model)
#| label: overunder
#| fig-width: 9
#| fig-height: 6
#SPI overperformers
spi_overperformers_df <- SPI_prediction_data %>%
filter(date==2022) %>%
mutate(resid=SPI.INDEX-SPI_predicted_values) %>%
arrange(-resid) %>%
head(15)
spi_underperformers_df <- SPI_prediction_data %>%
filter(date==2022) %>%
mutate(resid=SPI.INDEX-SPI_predicted_values) %>%
arrange(resid) %>%
head(15)
spi_overperformers_plot <-  spi_overperformers_df %>%
bind_rows(spi_underperformers_df) %>%
arrange(resid)
spi_overperformers_plot <- spi_overperformers_plot %>%
mutate(country=factor(country, levels=unique(spi_overperformers_plot$country)),
group=if_else(resid>=0, 'above','below')) %>%
ggplot(aes(x=country, y=resid, color=group)) +
geom_segment( aes(x=country ,xend=country, y=0, yend=resid), color="black") +
geom_point(size=3) +
scale_color_manual(name="",
labels = c("Over-performers", "Under-performers"),
values = c('above'="#1A9850", 'below'="#D73027")) +
coord_flip() +
theme_spi() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position = 'bottom'
) +
xlab("") +
ylab("SPI (deviation)")
# do same for ODIN
odin_overperformers_df <- ODIN_prediction_data %>%
filter(date==2022) %>%
mutate(resid=ODIN_score-ODIN_predicted_values) %>%
arrange(-resid) %>%
head(15)
odin_underperformers_df <- ODIN_prediction_data %>%
filter(date==2022) %>%
mutate(resid=ODIN_score-ODIN_predicted_values) %>%
arrange(resid) %>%
head(15)
odin_overperformers_plot <-  odin_overperformers_df %>%
bind_rows(odin_underperformers_df) %>%
arrange(resid)
odin_overperformers_plot <- odin_overperformers_plot %>%
mutate(country=factor(country, levels=unique(odin_overperformers_plot$country)),
group=if_else(resid>=0, 'above','below')) %>%
ggplot(aes(x=country, y=resid, color=group)) +
geom_segment( aes(x=country ,xend=country, y=0, yend=resid), color="black") +
geom_point(size=3) +
scale_color_manual(name="",
labels = c("Over-performers", "Under-performers"),
values = c('above'="#1A9850", 'below'="#D73027")) +
coord_flip() +
theme_spi() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position = 'none',
) +
xlab("") +
ylab("ODIN (deviation)")
spi_overperformers_plot + odin_overperformers_plot +
plot_annotation(
# title='Top 15 Over/Under-Performers on SPI overall score compared to GDP per capita and Human Capital Index',
caption=str_wrap('Over and under performers calculated by taking a country specific time trend using OLS regression of SPI overall score or ODIN score on the year using data from 2016 to 2020 and calculting residuals from this regression in 2022.',100)
)
#create table
spi_overunder_table <- spi_overperformers_df %>%
bind_rows(spi_underperformers_df) %>%
arrange(-resid)  %>%
mutate(resid=round(resid,1)) %>%
rename(`SPI Difference`=resid,
`SPI Country`=country) %>%
ungroup() %>%
select(`SPI Country`, `SPI Difference`)
odin_overunder_table <- odin_overperformers_df %>%
bind_rows(odin_underperformers_df) %>%
mutate(resid=round(resid,1)) %>%
arrange(-resid)  %>%
rename(`ODIN Difference`=resid,
`ODIN Country`=country) %>%
ungroup() %>%
select(`ODIN Country`, `ODIN Difference`)
overunder_tab <- cbind(spi_overunder_table, odin_overunder_table)
flextable(overunder_tab
) %>%
add_header_lines('SPI and ODIN Over/Under-performers in 2022 compared to country time trend from 2016 to 2020.')
#get absolute deviation and correlation
spi_performers_df <- SPI_prediction_data %>%
filter(date==2022) %>%
mutate(spi_resid=SPI.INDEX-SPI_predicted_values)
odin_performers_df <- ODIN_prediction_data %>%
filter(date==2022) %>%
mutate(odin_resid=ODIN_score-ODIN_predicted_values)
#get absolute deviation and correlation
spi_performers_df <- SPI_prediction_data %>%
filter(date==2022) %>%
mutate(spi_resid=SPI.INDEX-SPI_predicted_values)
#mean absolute deviation
mean(abs(spi_resid))
#get absolute deviation and correlation
spi_performers_df <- SPI_prediction_data %>%
filter(date==2022) %>%
mutate(spi_resid=SPI.INDEX-SPI_predicted_values)
#mean absolute deviation
mean(abs(spi_performers_df$spi_resid))
odin_performers_df <- ODIN_prediction_data %>%
filter(date==2022) %>%
mutate(odin_resid=ODIN_score-ODIN_predicted_values)
performers_df <- spi_performers_df %>%
left_join(odin_performers_df)
#get absolute deviation and correlation
spi_performers_df <- SPI_prediction_data %>%
filter(date==2022) %>%
mutate(spi_resid=SPI.INDEX-SPI_predicted_values)
#mean absolute deviation
mean(abs(spi_performers_df$spi_resid))
odin_performers_df <- ODIN_prediction_data %>%
filter(date==2022) %>%
mutate(odin_resid=ODIN_score-ODIN_predicted_values)
#mean absolute deviation
mean(abs(odin_performers_df$odin_resid))
performers_df <- spi_performers_df %>%
left_join(odin_performers_df)
#get absolute deviation and correlation
spi_performers_df <- SPI_prediction_data %>%
filter(date==2022) %>%
mutate(spi_resid=SPI.INDEX-SPI_predicted_values)
#mean absolute deviation
mean(abs(spi_performers_df$spi_resid))
odin_performers_df <- ODIN_prediction_data %>%
filter(date==2022) %>%
mutate(odin_resid=ODIN_score-ODIN_predicted_values)
#mean absolute deviation
mean(abs(odin_performers_df$odin_resid))
performers_df <- spi_performers_df %>%
left_join(odin_performers_df)
cor(performers_df$spi_resid, performers_df$odin_resid)
